var scene, camera, controls, renderer, raycaster, projector, mouseVector, renderlist, gap;
var geometry, material, mesh, startpos, depth;


function main()
{
    gap = 10;
    depth = 5;
    
    init();
    animate();

    function init() {

	scene = new THREE.Scene();

	camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 10000 );
	camera.position.z = 1000;

	projector = new THREE.Projector();
	mouseVector = new THREE.Vector3();

	var light = new THREE.DirectionalLight( 0xffffff, 1 );
	light.position.set( 0.2, 0.4, 1 ).normalize();
	scene.add( light );

        controls = new THREE.OrbitControls(camera);
	controls.damping = 0.2;
	controls.minPolarAngle = Math.PI/2;
	controls.maxPolarAngle = Math.PI/2;	
	controls.minAzimuthAngle = -Math.PI/2;
	controls.maxAzimuthAngle = Math.PI/2;

	geometry = new THREE.BoxGeometry(1000, 1000, depth );
	material = new THREE.MeshPhongMaterial({ color: 0x5F9F9F, shininess:70} );
	mesh = new THREE.Mesh( geometry, material );

	mesh.position.set(0,0,0);
	scene.add( mesh );

	renderer = new THREE.WebGLRenderer({antialias:true});
	renderer.setSize( window.innerWidth, window.innerHeight );	

	document.body.appendChild( renderer.domElement );

	document.addEventListener( 'mousedown', onMouseDown, false);
	window.addEventListener('resize', onWindowResize, false);
    }

    function animate() {

	requestAnimationFrame( animate );
	//controls.update();


	renderer.render( scene, camera );

    }

    function onMouseDown(e)
    {
	mouseVector.x = 2*(e.clientX / window.innerWidth) -1 ;
	mouseVector.y = 1 - 2 * ( e.clientY / window.innerHeight );

	var vector = new THREE.Vector3( mouseVector.x, mouseVector.y, 1 ).unproject( camera );

	raycaster = new THREE.Raycaster( camera.position, vector.sub( camera.position ).normalize() );
	var intersects = raycaster.intersectObjects(scene.children);

	if (intersects[0])
	{
	    var rmObject = intersects[0].object;
	    var rmGeomParams = rmObject.geometry.parameters;
	    var bigheight = (rmGeomParams.height + gap)/4;
	    var height = (rmGeomParams.height - gap)/2;

	    if (height > 5) //put a lower bound on how small these tiles get
	    {
		
		scene.remove(intersects[0].object);
		
		var geom = new THREE.BoxGeometry(height,
						 height,
						 rmGeomParams.depth);
		
		var mesh0 = new THREE.Mesh(geom, material);
		mesh0.position.addVectors(rmObject.position,
					  new THREE.Vector3(bigheight, bigheight, 0));
		var mesh1 = new THREE.Mesh(geom, material);
		mesh1.position.addVectors(rmObject.position,
					  new THREE.Vector3(-bigheight, bigheight, 0));
		var mesh2 = new THREE.Mesh(geom, material);
		mesh2.position.addVectors(rmObject.position,
					  new THREE.Vector3(bigheight, -bigheight, 0));
		var mesh3 = new THREE.Mesh(geom, material);
		mesh3.position.addVectors(rmObject.position,
					  new THREE.Vector3(-bigheight,-bigheight, 0));
		
		scene.add(mesh0);
		scene.add(mesh1);
		scene.add(mesh2);
		scene.add(mesh3);
	    }
	}
    }

    function onWindowResize() {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize( window.innerWidth, window.innerHeight );
    }
}
